"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.paginate = exports.getFilterTokens = exports.OperatorSymbolToFunction = exports.isOperator = exports.FilterOperator = exports.Paginated = void 0;
const typeorm_1 = require("typeorm");
const common_1 = require("@nestjs/common");
const lodash_1 = require("lodash");
const querystring_1 = require("querystring");
class Paginated {
}
exports.Paginated = Paginated;
var FilterOperator;
(function (FilterOperator) {
    FilterOperator["EQ"] = "$eq";
    FilterOperator["GT"] = "$gt";
    FilterOperator["GTE"] = "$gte";
    FilterOperator["IN"] = "$in";
    FilterOperator["NULL"] = "$null";
    FilterOperator["LT"] = "$lt";
    FilterOperator["LTE"] = "$lte";
    FilterOperator["BTW"] = "$btw";
    FilterOperator["NOT"] = "$not";
})(FilterOperator = exports.FilterOperator || (exports.FilterOperator = {}));
function isOperator(value) {
    return (0, lodash_1.values)(FilterOperator).includes(value);
}
exports.isOperator = isOperator;
exports.OperatorSymbolToFunction = new Map([
    [FilterOperator.EQ, typeorm_1.Equal],
    [FilterOperator.GT, typeorm_1.MoreThan],
    [FilterOperator.GTE, typeorm_1.MoreThanOrEqual],
    [FilterOperator.IN, typeorm_1.In],
    [FilterOperator.NULL, typeorm_1.IsNull],
    [FilterOperator.LT, typeorm_1.LessThan],
    [FilterOperator.LTE, typeorm_1.LessThanOrEqual],
    [FilterOperator.BTW, typeorm_1.Between],
    [FilterOperator.NOT, typeorm_1.Not],
]);
function getFilterTokens(raw) {
    const tokens = [];
    const matches = raw.match(/(\$\w+):/g);
    if (matches) {
        const value = raw.replace(matches.join(''), '');
        tokens.push(...matches.map((token) => token.substring(0, token.length - 1)), value);
    }
    else {
        tokens.push(raw);
    }
    if (tokens.length === 0 || tokens.length > 3) {
        return [];
    }
    else if (tokens.length === 2) {
        if (tokens[1] !== FilterOperator.NULL) {
            tokens.unshift(null);
        }
    }
    else if (tokens.length === 1) {
        if (tokens[0] === FilterOperator.NULL) {
            tokens.unshift(null);
        }
        else {
            tokens.unshift(null, FilterOperator.EQ);
        }
    }
    return tokens;
}
exports.getFilterTokens = getFilterTokens;
function parseFilter(query, config) {
    const filter = {};
    for (const column of Object.keys(query.filter)) {
        if (!(column in config.filterableColumns)) {
            continue;
        }
        const allowedOperators = config.filterableColumns[column];
        const input = query.filter[column];
        const statements = !Array.isArray(input) ? [input] : input;
        for (const raw of statements) {
            const tokens = getFilterTokens(raw);
            if (tokens.length === 0) {
                continue;
            }
            const [op2, op1, value] = tokens;
            if (!isOperator(op1) || !allowedOperators.includes(op1)) {
                continue;
            }
            if (isOperator(op2) && !allowedOperators.includes(op2)) {
                continue;
            }
            if (isOperator(op1)) {
                switch (op1) {
                    case FilterOperator.BTW:
                        filter[column] = exports.OperatorSymbolToFunction.get(op1)(...value.split(','));
                        break;
                    case FilterOperator.IN:
                        filter[column] = exports.OperatorSymbolToFunction.get(op1)(value.split(','));
                        break;
                    default:
                        filter[column] = exports.OperatorSymbolToFunction.get(op1)(value);
                        break;
                }
            }
            if (isOperator(op2)) {
                filter[column] = exports.OperatorSymbolToFunction.get(op2)(filter[column]);
            }
        }
    }
    return filter;
}
async function paginate(query, repo, config) {
    var _a, _b;
    let page = query.page || 1;
    const limit = Math.min(query.limit || config.defaultLimit || 20, config.maxLimit || 100);
    const sortBy = [];
    const searchBy = [];
    const path = query.path;
    function isEntityKey(entityColumns, column) {
        return !!entityColumns.find((c) => c === column);
    }
    if (config.sortableColumns.length < 1)
        throw new common_1.ServiceUnavailableException();
    if (query.sortBy) {
        for (const order of query.sortBy) {
            if (isEntityKey(config.sortableColumns, order[0]) && ['ASC', 'DESC'].includes(order[1])) {
                sortBy.push(order);
            }
        }
    }
    if (!sortBy.length) {
        sortBy.push(...(config.defaultSortBy || [[config.sortableColumns[0], 'ASC']]));
    }
    if (config.searchableColumns) {
        if (query.searchBy) {
            for (const column of query.searchBy) {
                if (isEntityKey(config.searchableColumns, column)) {
                    searchBy.push(column);
                }
            }
        }
        else {
            searchBy.push(...config.searchableColumns);
        }
    }
    if (page < 1)
        page = 1;
    let [items, totalItems] = [[], 0];
    let queryBuilder;
    if (repo instanceof typeorm_1.Repository) {
        queryBuilder = repo
            .createQueryBuilder('e')
            .take(limit)
            .skip((page - 1) * limit);
    }
    else {
        queryBuilder = repo.take(limit).skip((page - 1) * limit);
    }
    if ((_a = config.relations) === null || _a === void 0 ? void 0 : _a.length) {
        config.relations.forEach((relation) => {
            queryBuilder.leftJoinAndSelect(`${queryBuilder.alias}.${relation}`, `${queryBuilder.alias}_${relation}`);
        });
    }
    for (const order of sortBy) {
        if (order[0].split('.').length > 1) {
            queryBuilder.addOrderBy(`${queryBuilder.alias}_${order[0]}`, order[1]);
        }
        else {
            queryBuilder.addOrderBy(`${queryBuilder.alias}.${order[0]}`, order[1]);
        }
    }
    if (((_b = config.select) === null || _b === void 0 ? void 0 : _b.length) > 0) {
        const mappedSelect = config.select.map((col) => {
            if (col.includes('.')) {
                const [rel, relCol] = col.split('.');
                return `${queryBuilder.alias}_${rel}.${relCol}`;
            }
            return `${queryBuilder.alias}.${col}`;
        });
        queryBuilder.select(mappedSelect);
    }
    if (config.where) {
        queryBuilder.andWhere(new typeorm_1.Brackets((qb) => qb.andWhere(config.where)));
    }
    if (config.withDeleted) {
        queryBuilder.withDeleted();
    }
    if (query.search && searchBy.length) {
        queryBuilder.andWhere(new typeorm_1.Brackets((qb) => {
            for (const column of searchBy) {
                const propertyPath = column.split('.');
                if (propertyPath.length > 1) {
                    const condition = {
                        operator: 'ilike',
                        parameters: [`${qb.alias}_${column}`, `:${column}`],
                    };
                    qb.orWhere(qb['createWhereConditionExpression'](condition), {
                        [column]: `%${query.search}%`,
                    });
                }
                else {
                    qb.orWhere({
                        [column]: (0, typeorm_1.ILike)(`%${query.search}%`),
                    });
                }
            }
        }));
    }
    if (query.filter) {
        const filter = parseFilter(query, config);
        queryBuilder.andWhere(new typeorm_1.Brackets((qb) => {
            for (const column in filter) {
                const propertyPath = column.split('.');
                if (propertyPath.length > 1) {
                    const condition = qb['getWherePredicateCondition'](column, filter[column]);
                    let parameters = { [column]: filter[column].value };
                    // TODO: refactor below
                    switch (condition.operator) {
                        case 'between':
                            condition.parameters = [`${qb.alias}_${column}`, `:${column}_from`, `:${column}_to`];
                            parameters = {
                                [column + '_from']: filter[column].value[0],
                                [column + '_to']: filter[column].value[1],
                            };
                            break;
                        case 'in':
                            condition.parameters = [`${qb.alias}_${column}`, `:...${column}`];
                            break;
                        default:
                            condition.parameters = [`${qb.alias}_${column}`, `:${column}`];
                            break;
                    }
                    qb.andWhere(qb['createWhereConditionExpression'](condition), parameters);
                }
                else {
                    qb.andWhere({
                        [column]: filter[column],
                    });
                }
            }
        }));
    }
    ;
    [items, totalItems] = await queryBuilder.getManyAndCount();
    let totalPages = totalItems / limit;
    if (totalItems % limit)
        totalPages = Math.ceil(totalPages);
    const sortByQuery = sortBy.map((order) => `&sortBy=${order.join(':')}`).join('');
    const searchQuery = query.search ? `&search=${query.search}` : '';
    const searchByQuery = query.searchBy && searchBy.length ? searchBy.map((column) => `&searchBy=${column}`).join('') : '';
    const filterQuery = query.filter
        ? '&' +
            (0, querystring_1.stringify)((0, lodash_1.mapKeys)(query.filter, (_param, name) => 'filter.' + name), '&', '=', { encodeURIComponent: (str) => str })
        : '';
    const options = `&limit=${limit}${sortByQuery}${searchQuery}${searchByQuery}${filterQuery}`;
    const buildLink = (p) => path + '?page=' + p + options;
    const results = {
        data: items,
        meta: {
            itemsPerPage: limit,
            totalItems,
            currentPage: page,
            totalPages: totalPages,
            sortBy,
            search: query.search,
            searchBy: query.search ? searchBy : undefined,
            filter: query.filter,
        },
        links: {
            first: page == 1 ? undefined : buildLink(1),
            previous: page - 1 < 1 ? undefined : buildLink(page - 1),
            current: buildLink(page),
            next: page + 1 > totalPages ? undefined : buildLink(page + 1),
            last: page == totalPages || !totalItems ? undefined : buildLink(totalPages),
        },
    };
    return Object.assign(new Paginated(), results);
}
exports.paginate = paginate;
//# sourceMappingURL=paginate.js.map